/**

@mainpage 15-410 Project 3

@author Name1 (id1)
@author Name2 (id2)

Same drill as last time.

TODO LIST:
implement rollbacks on resource failure
think about readline
think about ZFOD and COW
make all scheduler assigns atomic (xchng)
Make idle thread run runnable_pool is empty

Design Decision Rationales:

Global scheduler lock - The reason we have a global scheduler lock
rather than one inside the scheduler is to avoid the following situation:
Consider thread 1 in fork() that grabs the scheduler's mutex. After it
grabs the mutex, a timer fires and a context switch is being serviced.
The context switcher also accesses the scheduler and tries to acquire
it's mutex, but it can't because thread 1 controls it. And thus,
execution stops because the scheduler waits forever.
With a global scheduler lock, syscalls the modify the scheduler are thread
safe.

Skip esp and eax save in syscall wrappers - This is to make sure syscall
restore and save registers follow the same stack pattern as a context switch
and subsequent return from a timer interrupt. This is to make implementing
exec and yield seamless.

*/
