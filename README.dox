/**

@mainpage 15-410 Project 3

@author Name1 (id1)
@author Name2 (id2)

Same drill as last time.

TODO LIST:
implement rollbacks on resource failure
think about readline
think about ZFOD and COW
make all scheduler assigns atomic (xchng)
Make idle thread run runnable_pool is empty

Design Decision Rationales:

Sleeping pool design - In order to maintain constant time context switching,
we decided on implementing the sleeping pool as a linked list that maintains
an ordering. This allows us to check whether or not we need to wake up a thread
in constant time by simply looking at the first element - which has the lowest
lookup time - and comparing it to the current time for every tick. Granted, a
sorted insertion into a linked list takes O(n) time, this is very much worth
it for the constant time wakeup procedure.

Global scheduler lock - The reason we have a global scheduler lock
rather than one inside the scheduler is to avoid the following situation:
Consider thread 1 in fork() that grabs the scheduler's mutex. After it
grabs the mutex, a timer fires and a context switch is being serviced.
The context switcher also accesses the scheduler and tries to acquire
it's mutex, but it can't because thread 1 controls it. And thus,
execution stops because the scheduler waits forever.
With a global scheduler lock, syscalls the modify the scheduler are thread
safe.

Skip esp and eax save in syscall wrappers - This is to make sure syscall
restore and save registers follow the same stack pattern as a context switch
and subsequent return from a timer interrupt. This is to make implementing
exec and yield seamless.

*/
